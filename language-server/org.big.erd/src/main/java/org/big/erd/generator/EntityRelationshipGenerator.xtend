/*
 * generated by Xtext 2.24.0
 */
package org.big.erd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.big.erd.entityRelationship.Attribute
import org.big.erd.entityRelationship.Model
import org.big.erd.entityRelationship.Entity
import org.big.erd.entityRelationship.DataType
import org.big.erd.entityRelationship.AttributeType
import org.big.erd.entityRelationship.Relationship
import java.util.Set
import org.eclipse.xtext.util.RuntimeIOException

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EntityRelationshipGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val diagram = resource.contents.get(0) as Model
		
		// Do not generate if generateSql is not set
		if (diagram.generateSql === null) {
			return
		}

		val name = (diagram.name ?: 'output') + '.sql'
		
		// TODO: Fix Weak entites (weak -> weak and strong -> weak)

		try {

			fsa.generateFile(name, '''
			«var Attribute primaryKey»
			«FOR entity : diagram.entities.reject[it.isWeak]»
				CREATE TABLE «entity.name» (
					«FOR attribute : entity.allAttributes.reject[it.type === AttributeType.DERIVED] SEPARATOR ', '»
						«attribute.name» «attribute.datatype.transformType»«IF attribute.type === AttributeType.KEY»«{primaryKey = attribute; null}»«ENDIF» «IF attribute.type !== AttributeType.NULLABLE»NOT NULL«ENDIF»		
					«ENDFOR»
					«IF entity.extends !== null»«entity.extends.key.name» «entity.extends.key.datatype.transformType»«ENDIF»
					«'\n'»
					PRIMARY KEY («primaryKey.name»)
					«IF entity.extends !== null»FOREIGN KEY («entity.extends.key.name») REFERENCES «entity.extends.name»(«entity.extends.key.name»)«ENDIF»
				);«'\n'»«'\n'»
			«ENDFOR»
			«var Attribute partialKey»		
			«FOR relationship : diagram.relationships.reject[!it.isWeak || it.left === null || it.right === null]»
				CREATE TABLE «relationship.weakEntity.name» ( 
					«FOR attribute : relationship.weakEntity.allAttributes.reject[it.type === AttributeType.DERIVED] SEPARATOR ', '»
						«attribute.name» «attribute.datatype.transformType»«IF attribute.type === AttributeType.PARTIAL_KEY»«{partialKey = attribute; null}»«ENDIF» «IF attribute.type !== AttributeType.NULLABLE»NOT NULL«ENDIF»		
					«ENDFOR»
					«relationship.strongEntity.key.name» «relationship.strongEntity.key.datatype.transformType» NOT NULL
					«'\n'»
					PRIMARY KEY («partialKey.name», «relationship.strongEntity.key.name»)
					FOREIGN KEY («relationship.strongEntity.key.name») REFERENCES «relationship.strongEntity.name»(«relationship.strongEntity.key.name») 
						ON DELETE CASCADE
				);«'\n'»«'\n'»
			«ENDFOR»
			«FOR relationship : diagram.relationships.reject[it.isWeak || it.left === null]»
				CREATE TABLE «relationship.name» (
					«relationship.leftKey.name» «relationship.leftKey.datatype.transformType»,
					CONSTRAINT fk_«relationship.leftKey.name» FOREIGN KEY («relationship.leftKey.name»)
						REFERENCES «relationship.left.target.name»(«relationship.leftKey.name»),
					«relationship.rightKey.name» «relationship.rightKey.datatype.transformType»,
					CONSTRAINT fk_«relationship.rightKey.name» FOREIGN KEY («relationship.rightKey.name»)
						REFERENCES «relationship.right.target.name»(«relationship.rightKey.name»)
					«IF relationship.third !== null»
					«relationship.thirdKey.name» «relationship.thirdKey.datatype.transformType»,
					CONSTRAINT fk_«relationship.thirdKey.name» FOREIGN KEY («relationship.thirdKey.name»)
						REFERENCES «relationship.third.target.name»(«relationship.thirdKey.name»)
					«ENDIF»
				);«'\n'»«'\n'»
			«ENDFOR»
			'''
			)
		} catch (RuntimeIOException e) {
			throw new Error("Could not generate file. Did you open a folder?")
		}
	}

		private def transformType(DataType type) {
		switch (type) {
			// Default if no datatype is specified
			case DataType.NONE: {
				return 'varchar(255)'
			}
			case DataType.BOOLEAN: {
				return 'bit'
			}
			case DataType.DATETIME: {
				return 'datetime'
			}
			case DataType.DOUBLE: {
				return 'real'
			}
			case DataType.INT: {
				return 'int'
			}
			case DataType.STRING: {
				return 'varchar(255)'
			}
		}
	}

	private def getStrongEntity(Relationship r) {
		if (r.left.target.isWeak) {
			return r.right.target
		} else {
			return r.left.target
		}
	}

	private def getWeakEntity(Relationship r) {
		if (r.left.target.isWeak) {
			return r.left.target
		} else {
			return r.right.target
		}
	}

	private def Set<Attribute> getAllAttributes(Entity entity) {
		val attributes = newHashSet
		attributes += entity.attributes
		return attributes
	}
	
	/* 
	private def getStrongEntityName(Entity entity, Model m) {
		val weakRelationships = m.relationships.reject[!it.isWeak]
		for (Relationship r : weakRelationships) {
			if (r.left.target === entity) {
				return r.right.target.name
			}
			if (r.right.target === entity) {
				return r.left.target.name
			}
		}
	}
	*/

	private def getKey(Entity entity) {
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getLeftKey(Relationship relationship) {
		val entity = relationship.left.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getRightKey(Relationship relationship) {
		val entity = relationship.right.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getThirdKey(Relationship relationship) {
		val entity = relationship.third.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}
}