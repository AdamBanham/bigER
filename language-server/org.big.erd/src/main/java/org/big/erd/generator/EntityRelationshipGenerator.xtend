/*
 * generated by Xtext 2.24.0
 */
package org.big.erd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.big.erd.entityRelationship.Attribute
import org.big.erd.entityRelationship.Model
import org.big.erd.entityRelationship.Entity
import org.big.erd.entityRelationship.DataType
import org.big.erd.entityRelationship.AttributeType
import org.big.erd.entityRelationship.Relationship
import java.util.Set
import org.eclipse.xtext.util.RuntimeIOException

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EntityRelationshipGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val diagram = resource.contents.get(0) as Model
		
		// Check whether the generate option is set
		if (diagram.generateOption === null || diagram.generateOption.generateOptionType.toString === 'off') {
			return;
		}

		val name = (diagram.name ?: 'output') + '.sql'
		
		// TODO: Fix Weak entites (weak -> weak and strong -> weak)
		// TODO: Rewrite Generatot

		try {

			fsa.generateFile(name, '''
			«var Attribute primaryKey»
			«FOR entity : diagram.entities.reject[it.isWeak]»
				CREATE TABLE «entity.name» (
					«FOR attribute : entity.allAttributes.reject[it.type === AttributeType.DERIVED] SEPARATOR ', '»
						«attribute.name» «attribute.datatype.transformDataType» «IF attribute.type === AttributeType.KEY»«{primaryKey = attribute; null}»«ENDIF» «IF attribute.type !== AttributeType.OPTIONAL»NOT NULL«ENDIF»		
					«ENDFOR»
					«IF entity.extends !== null»«entity.extends.key.name» «entity.extends.key.datatype.transformDataType»«ENDIF»
					«'\n'»
					PRIMARY KEY («primaryKey.name»)
					«IF entity.extends !== null»FOREIGN KEY («entity.extends.key.name») REFERENCES «entity.extends.name»(«entity.extends.key.name»)«ENDIF»
				);«'\n'»«'\n'»
			«ENDFOR»
			«var Attribute partialKey»		
			«FOR relationship : diagram.relationships.reject[!it.isWeak || it.first === null || it.second === null]»
				CREATE TABLE «relationship.weakEntity.name» ( 
					«FOR attribute : relationship.weakEntity.allAttributes.reject[it.type === AttributeType.DERIVED] SEPARATOR ', '»
						«attribute.name» «attribute.datatype.transformDataType»«IF attribute.type === AttributeType.PARTIAL_KEY»«{partialKey = attribute; null}»«ENDIF» «IF attribute.type !== AttributeType.OPTIONAL»NOT NULL«ENDIF»		
					«ENDFOR»
					«relationship.strongEntity.key.name» «relationship.strongEntity.key.datatype.transformDataType» NOT NULL
					«'\n'»
					PRIMARY KEY («partialKey.name», «relationship.strongEntity.key.name»)
					FOREIGN KEY («relationship.strongEntity.key.name») REFERENCES «relationship.strongEntity.name»(«relationship.strongEntity.key.name») 
						ON DELETE CASCADE
				);«'\n'»«'\n'»
			«ENDFOR»
			«FOR relationship : diagram.relationships.reject[it.isWeak || it.first === null]»
				CREATE TABLE «relationship.name» (
					«relationship.leftKey.name» «relationship.leftKey.datatype.transformDataType»,
					CONSTRAINT fk_«relationship.leftKey.name» FOREIGN KEY («relationship.leftKey.name»)
						REFERENCES «relationship.first.target.name»(«relationship.leftKey.name»),
					«relationship.rightKey.name» «relationship.rightKey.datatype.transformDataType»,
					CONSTRAINT fk_«relationship.rightKey.name» FOREIGN KEY («relationship.rightKey.name»)
						REFERENCES «relationship.second.target.name»(«relationship.rightKey.name»)
					«IF relationship.third !== null»
					«relationship.thirdKey.name» «relationship.thirdKey.datatype.transformDataType»,
					CONSTRAINT fk_«relationship.thirdKey.name» FOREIGN KEY («relationship.thirdKey.name»)
						REFERENCES «relationship.third.target.name»(«relationship.thirdKey.name»)
					«ENDIF»
				);«'\n'»«'\n'»
			«ENDFOR»
			'''
			)
		} catch (RuntimeIOException e) {
			throw new Error("Could not generate file. Did you open a folder?")
		}
	}

		private def transformDataType(DataType dataType) {
			if(dataType === null) {
				return ''
			}
			
			val type = dataType.type
			var size = dataType.size
		
			if (size != 0) {
				return type +  "(" + size + ")";
			}
		
		return type
	}

	private def getStrongEntity(Relationship r) {
		if (r.first.target.isWeak) {
			return r.second.target
		} else {
			return r.first.target
		}
	}

	private def getWeakEntity(Relationship r) {
		if (r.first.target.isWeak) {
			return r.first.target
		} else {
			return r.second.target
		}
	}

	private def Set<Attribute> getAllAttributes(Entity entity) {
		val attributes = newHashSet
		attributes += entity.attributes
		return attributes
	}
	
	/* 
	private def getStrongEntityName(Entity entity, Model m) {
		val weakRelationships = m.relationships.reject[!it.isWeak]
		for (Relationship r : weakRelationships) {
			if (r.left.target === entity) {
				return r.right.target.name
			}
			if (r.right.target === entity) {
				return r.left.target.name
			}
		}
	}
	*/

	private def getKey(Entity entity) {
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getLeftKey(Relationship relationship) {
		val entity = relationship.first.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getRightKey(Relationship relationship) {
		val entity = relationship.second.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}

	private def getThirdKey(Relationship relationship) {
		val entity = relationship.third.target
		for(Attribute a : entity.attributes) {
			if (a.type === AttributeType.KEY) {
				return a
			}
		}
	}
}