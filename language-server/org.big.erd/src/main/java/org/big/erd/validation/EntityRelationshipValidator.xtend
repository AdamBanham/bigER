/*
 * generated by Xtext 2.24.0
 */
package org.big.erd.validation

import org.big.erd.entityRelationship.Model
import org.big.erd.entityRelationship.EntityRelationshipPackage
import com.google.common.collect.Multimaps
import org.eclipse.xtext.validation.Check
import org.big.erd.entityRelationship.AttributeType
import org.big.erd.entityRelationship.Attribute
import org.big.erd.entityRelationship.Entity

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EntityRelationshipValidator extends AbstractEntityRelationshipValidator {

	public static String MISSING_MODEL_NAME = "missingModelName";
	public static String MISSING_ATTRIBUTE_DATATYPE = "missingAttributeDatatype";
	public static String LOWERCASE_ENTITY_NAME = "lowercaseEntityName";
	
	@Check
	def checkModel(Model model) {
		if (model.name === null || model.name.isBlank) {
			error('''Missing model name''', EntityRelationshipPackage.Literals.MODEL__NAME, MISSING_MODEL_NAME)
		}
	}
	
	@Check
	def checkUppercaseName(Entity entity) {
		if (!Character.isUpperCase(entity.name.charAt(0))) {
			info('''Entity name '«entity.name»' should start with an upper-case letter''', EntityRelationshipPackage.Literals.ENTITY__NAME, LOWERCASE_ENTITY_NAME)
		}
	}
	
	@Check
	def checkAttribute(Attribute attribute) {
		val model = attribute.eContainer.eContainer as Model
		if (model.generateOption !== null && model.generateOption.generateOptionType.toString === 'sql') {
			if (attribute.datatype === null || attribute.datatype.toString.nullOrEmpty) {
				warning('''Missing datatype for attribute''', EntityRelationshipPackage.Literals.ATTRIBUTE__DATATYPE, MISSING_ATTRIBUTE_DATATYPE)
			}
		}
	}
	
	// Names are unique for entities and relationships
    @Check
	def uniqueNames(Model model) {
        // Entities
        val entityNames = Multimaps.index(model.entities, [name ?: ''])
        entityNames.keySet.forEach [ name |
        	val commonName = entityNames.get(name)
			if (commonName.size > 1) 
				commonName.forEach [
					error('''Multiple entites named '«name»'«».''', it, EntityRelationshipPackage.Literals.ENTITY__NAME)
			]
		]
		// Relationships
		val relNames = Multimaps.index(model.relationships, [name ?: ''])
        relNames.keySet.forEach [ name |
			val commonName = relNames.get(name)
			if (commonName.size > 1) 
				commonName.forEach [
					error('''Multiple relationships named '«name»'«».''', it, EntityRelationshipPackage.Literals.RELATIONSHIP__NAME)
			]
		]
    }
    
    
	// Check if strong entities contain primary key and no partial key
	@Check
	def containsKey(Model model) {
		val entities = model.entities?.filter[e | !e.weak]
        entities.forEach [ e |
			val attributes = e.attributes?.filter[a | a.type === AttributeType.KEY]
			if (attributes.isNullOrEmpty) 
				info('''Missing primary key for entity''', e, EntityRelationshipPackage.Literals.ENTITY__NAME)
		]
    }

	// Check if weak entities contain partial key and no primary key
	@Check
	def containsPartialKey(Model model) {
		val entities = model.entities?.filter[e | e.weak]
        entities.forEach [ e |
			val attributes = e.attributes?.filter[a | a.type == AttributeType.PARTIAL_KEY]
			if (attributes.isNullOrEmpty) 
				info('''Missing partial-key for weak entity''', e, EntityRelationshipPackage.Literals.ENTITY__NAME)
		]
    }
    
    /* 
    @Check
	def checkNoCycleInheritance(Entity entity) {
		// dont check if entity does not extend
		if (entity.extends === null)
			return
		
		val visitedEntities = newHashSet(entity)
		var current = entity.extends
		while (current !== null) {
			if (visitedEntities.contains(current)) {
				error('''Cycle in the inheritance of entity '«current.name»' ''', current, EntityRelationshipPackage.Literals.ENTITY__EXTENDS)
			}
			visitedEntities.add(current)
			current = current.extends
		}
	}
	*/
	
}
